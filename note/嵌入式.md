# 可重入

- 所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。**一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。****也可以这样理解，重入即表示重复进入**，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括  static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。

# 内存四区

## 1.代码区

　　程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。

　　注意："int a = 0;"语句可拆分成"int a;"和"a = 0"，定义变量a的"int a;"语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有"a = 0"这句。

## 2.静态区

　　静态区存放程序中所有的全局变量和静态变量。

## 3.栈区

　　栈（stack）是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。

- 每个线程都有自己专属的栈；
- 栈的最大尺寸固定，超出则引起栈溢出；
- 变量离开作用域后栈上的内存会自动释放。

## 4.堆区

　　堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决上面实验三造成的内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制）。

# IIC

***IIC（Inter-Integrated Circuit）内部集成电路；多主机总线，非全双工***

还是假设A给B发数据（这里A.SCL接B.SCL, A.SDA接B.SDA）。起初SDA和SCL上的电平都为高电平。然后A先把SDA拉低，等SDA变为低电平后再把SCL拉低(以上两个动作构成了iic的起始位)，此时SDA就可以发送数据了，与此同时，SCL发送一定周期的脉冲（周期和PCLK有关，一般会在IIC的控制寄存器中设置）。SDA发送数据和SCL发送脉冲的要符合的关系是：SDA必须在SCL是高电平是保持有效，在SCL是低电平时发送下一位（SCL会在上升沿对SDA进行采样）。规定一次必须传8位数据，8位数据传输结束后A释放SDA，但SCL再发一个脉冲（这是第九个脉冲），这会触发B通过将SDA置为低电平表示确认（该低电平称为ACK）。最后SCL先变为高电平，SDA再变为高电平（以上两个动作称为结束标志）如果B没有将SDA置为0，则A停止发送下一帧数据。IIC总线（即SDA和SCL）上的每个设备都有唯一地址，数据包传输时先发送地址位，接着才是数据。一个地址字节由7个地址位（可以挂128个设备）和1个指示位组成（7位寻址模式）。指示位是0表示写，1表示读。还有10位寻址模式，使用两个字节来保存地址，第一个字节的最低两位和第二个字节的8位合起来构成10位地址。

- IIC数据从最高位开始传输。
- 用7bit表示从地址，那么可以挂载的从设备数是2的7次方128个。处理器想写的话：先发送起始位，再发一个8bit数据：前7bit表示从地址，第8bit表示读或者写。0write是处理器往IIC从设备发，1read是IIC从设备往处理器发。第9个时钟周期回复响应信号。

# SPI

***SPI(Serial Peripheral Interface)，串行外设接口。 由Motorola提出的全双工三线同步串行外围接口，采用主从模式（Master Slave）架构***

**Features**
  高速、全双工、同步通信、四线接口
**Pin**
  SCK：时钟信号 -> 主机产生，速率受限低速设备
  SS(CS/NSS)：片选 -> 低电平有效，同一时刻只允许一个设备连接
  MISO(SDI)：主设备输入/从设备输出
  MOSI(SDO)：主设备输出/从设备输入

# 形参与实参

***形式参数：形参是函数被调用时用于接收实参值的变量。***

实参(argument)： 全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。    

形参(parameter)：全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。

# Linux驱动

**三种驱动设备分类**

    字符设备(char)
    实际上就是字节设备，对设备操作的读写操作是以字节为最小单位，如控制LED灯的亮灭，串口的读写，
    
    块设备(block)
    实际是就是存储设备，其驱动操作的最小单位是块，对整个块进行操作，如HDD，Flash 都是以一个固定的Block大小进行读写，如512B等等。修改时需要读出整块到内存，对需要的地方进行修改后，再覆写整块
    
    网络设备(network)
    是一套通用的接口,实际上已经包含在内核，无需开发
# UCOSⅡ

## 锁

- OSSchedLock();
- OSSchedUnlock();

## 延时

- OSTimeDly(1000);

## 创建任务

OSTaskCreate(sign_task,(void *)0,(OS_STK*)&SIGN_TASK_STK[SIGN_STK_SIZE-1],SIGN_TASK_PRIO);

# gcc

gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：

- 1、预处理,生成 .i 的文件[预处理器cpp] 
- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs] 
- 3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as] 
- 4、连接目标代码, 生成可执行程序 [链接器ld] 

**x language filename** 

设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。也就是根据约定 C 语言的后缀名称是 .c 的，而 C++ 的后缀名是 .C  或者 .cpp, 如果你很个性，决定你的 C 代码文件的后缀名是 .pig 哈哈，那你就要用这个参数,  这个参数对他后面的文件名都起作用，除非到了下一个参数的使用。 可以使用的参数吗有下面的这些：'c', 'objective-c',  'c-header', 'c++', 'cpp-output', 'assembler', 与 'assembler-with-cpp'。

看到英文，应该可以理解的。 

例子用法:

```
gcc -x c hello.pig 
```

**-x none filename** 

关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。

例子用法: 

```
gcc -x c hello.pig -x none hello2.c 
```

**-c** 

只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 

例子用法: 

```
gcc -c hello.c 
```

他将生成 .o 的 obj 文件 

**-S** 

只激活预处理和编译，就是指把文件编译成为汇编代码。 

例子用法: 

```
gcc -S hello.c 
```

他将生成 .s 的汇编代码，你可以用文本编辑器察看。 

**-E** 

只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面。 

例子用法: 

```
gcc -E hello.c > pianoapan.txt 
gcc -E hello.c | more 
```

慢慢看吧, 一个 hello word 也要与处理成800行的代码。 

**-o** 

制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out, 很难听, 如果你和我有同感，改掉它, 哈哈。

例子用法: 

```
gcc -o hello.exe hello.c (哦,windows用习惯了) 
　　gcc -o hello.asm -S hello.c
```

| ansi         | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |
| ------------ | ------------------------------------------------------------ |
| -c           | 只编译并生成目标文件。                                       |
| -DMACRO      | 以字符串"1"定义 MACRO 宏。                                   |
| -DMACRO=DEFN | 以字符串"DEFN"定义 MACRO 宏。                                |
| -E           | 只运行 C 预编译器。                                          |
| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |
| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |
| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |
| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |
| -m486        | 针对 486 进行代码优化。                                      |
| -o FILE      | 生成指定的输出文件。用在生成可执行文件时。                   |
| -O0          | 不进行优化处理。                                             |
| -O 或 -O1    | 优化生成代码。                                               |
| -O2          | 进一步优化。                                                 |
| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |
| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |
| -static      | 禁止使用共享连接。                                           |
| -UMACRO      | 取消对 MACRO 宏的定义。                                      |
| -w           | 不生成任何警告信息。                                         |
| -Wall        | 生成所有警告信息。                                           |

将编译程序分成若干个“遍”是为了使程序的结构更加清晰。
遍：就是对源程序或者源程序的中间结果进行从头到尾的扫描依次，并且作出相应的处理，生成新的中间结果或者目标程序。

int[].length
java.util.Scanner Scanner.hasNextLine
String.charAt	indexOf() substring(int start, int end)

正则表达式
进行字符串匹配和处理的强大工具（描述字符串复杂规则的工具）
import java.util.regex.Matcher;
import java.util.regex.Pattern;
public static void main(String[] args) {
        String str = "成都市(成华区)(武侯区)(高新区)";
        Pattern p = Pattern.compile(".*?(?=\\()");
        Matcher m = p.matcher(str);
        while(m.find()) {
            System.out.println(m.group());
        }
    }

import java.lang.StringBuffer;
indexOf("")	replace() append()	charAt()	substring(start)	substring(start,end)

static void dump2() throws IOException{
		//自动关闭流，InputStream和OutputStream重载了AutoCloseable接口
		//BufferedInputStream和BufferedOutputStream作为流的修饰器，使读写更高效
		try(InputStream in = new BufferedInputStream(new FileInputStream(src));
				OutputStream out = new BufferedOutputStream(new FileOutputStream(dest))){
			byte[] data = new byte[1024];
			int len;
			while((len = in.read(data)) != -1){
				out.write(data, 0, len);
			}
		}
	}

Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
java为数据结构中的映射定义了一个接口java.util.Map;它有四个实现类,分别是HashMap Hashtable LinkedHashMap 和TreeMap. 
synchronized [ˈsɪŋkrənaɪzd] 是Java的关键字，当它用来修饰一个方法或者一个代码块的时候
JDK1.5以后引入了自旋锁、锁粗化、轻量级锁，偏向锁来有优化关键字的性能。
final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源

反射创建对象
- 方法1：通过类对象调用newInstance()方法，例如：String.class.newInstance()
- 方法2：通过类对象的getConstructor()或getDeclaredConstructor()方法获得构造器（Constructor）对象并调用其newInstance()方法创建对象，例如：String.class.getConstructor(String.class).newInstance("Hello"); 
作用：反射机制指的是程序在运行时能够获取自身的信息。在JAVA中，只要给定类的名字，那么就可以通过反射机制来获取类的所有信息。 


创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
设计模式的详解

    一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点
    二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。
    三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。
    四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。
    五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。
行为型有：
    六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。
    七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。
    八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法得某些特定步骤。
    九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。
    十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。
    十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。
    十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系
    十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。
    十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。
    十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。
    十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。
结构型有：
    十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。
    十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，fa?ade提供了一高层接口，这个接口使得子系统更容易使用。
    十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问
    二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。
    二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。
    二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。
    二十三、Flyweight，享元模式

################################################################################

​					数据结构与算法
大O描述当数据结构中的元素增加时，算法的规模和性能在最坏情景下有多好。
大O还可以描述其它行为，比如内存消耗。因为集合类实际上是数据结构，因此我们一般使用大O符号基于时间，内存，性能选择最好的实现。大O符号可以对大量数据性能给予一个很好的说明。




##############################################################################################################
					网络基础
超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议
DNS服务将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网
OSI体系:应用层,(表示层,会话层,)运输层,网络层,数据链路层,物理层


应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。(电子邮件的 SMTP协议)

运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务.所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。
传输控制协议 TCP（Transmission Control Protocol）--提供面向连接的，可靠的数据传输服务
用户数据协议 UDP（User Datagram Protocol）--提供无连接的

网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报 ，简称 数据报。
互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。 在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在物理层上所传送的数据单位是比特。 物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。

# Linux网络编程

1. 套接字：源IP地址和目的IP地址以及源端口号和目的端口号的组合称为套接字。其用于标识客户端请求的服务器和服务。

## 常用的TCP/IP协议的3种套接字类型

**（1）流套接字（SOCK_STREAM）：**

流套接字用于提供面向连接、可靠的数据传输服务。该服务将保证数据能够实现无差错、无重复发送，并按顺序接收。流套接字之所以能够实现可靠的数据服务，原因在于其使用了传输控制协议，即TCP（The Transmission ControlProtocol）协议。

（**2） 数据报套接字（SOCK_DGRAM）：**

数据报套接字提供了一种无连接的服务。该服务并不能保证数据传输的可靠性，数据有可能在传输过程中丢失或出现数据重复，且无法保证顺序地接收到数据。数据报套接字使用UDP（User Datagram Protocol）协议进行数据的传输。由于数据报套接字不能保证数据传输的可靠性，对于有可能出现的数据丢失情况，需要在程序中做相应的处理。

**（3）原始套接字（SOCK_RAW）：（一般不用这个套接字）**

原始套接字(SOCKET_RAW)允许对较低层次的协议直接访问，比如IP、 ICMP协议，它常用于检验新的协议实现，或者访问现有服务中配置的新设备，因为RAW SOCKET可以自如地控制Windows下的多种协议，能够对网络底层的传输机制进行控制，所以可以应用原始套接字来操纵网络层和传输层应用。比如，我们可以通过RAW SOCKET来接收发向本机的ICMP、IGMP协议包，或者接收TCP/IP栈不能够处理的IP包，也可以用来发送一些自定包头或自定协议的IP包。网络监听技术很大程度上依赖于SOCKET_RAW


（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源）
ARQ协议  自动重传请求（Automatic Repeat-reQuest，ARQ）
停止等待ARQ协议
连续ARQ协议( 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。
TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。)
拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。(慢开始 、 拥塞避免 、快重传 和 快恢复)

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。
而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
Connection:keep-alive


    URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
    URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。
 安全性和资源消耗： HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。
    对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
    非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

DNS:53
TFTP:69
FTP:23
telnet:21
代理服务器（Proxy Server)

SSL：（Secure Socket Layer） 安全套接层
TLS：（Transport Layer Security）传输层安全性协议





##############################################################################################################
					Spring
MVC模式导致应用程序的不同方面(输入逻辑，业务逻辑和UI逻辑)分离，同时提供这些元素之间的松散耦合。
    模型(Model)封装了应用程序数据，通常它们将由POJO类组成。
    视图(View)负责渲染模型数据，一般来说它生成客户端浏览器可以解释HTML输出。
    控制器(Controller)负责处理用户请求并构建适当的模型，并将其传递给视图进行渲染。

Spring 最认同的技术是控制反转的依赖注入（DI）模式。控制反转（IoC）是一个通用的概念，它可以用许多不同的方式去表达，依赖注入仅仅是控制反转的一个具体的例子。

ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");
HelloWorld obj = (HelloWorld) context.getBean("helloWorld");
obj.getMessage();
第一步是我们使用框架 API ClassPathXmlApplicationContext() 来创建应用程序的上下文。这个 API 加载 beans 的配置文件并最终基于所提供的 API，它处理创建并初始化所有的对象，即在配置文件中提到的 beans。
第二步是使用已创建的上下文的 getBean() 方法来获得所需的 bean。这个方法使用 bean 的 ID 返回一个最终可以转换为实际对象的通用对象。一旦有了对象，你就可以使用这个对象调用任何类的方法。

Spring 容器是 Spring 框架的核心。容器将创建对象，把它们连接在一起，配置它们，并管理他们的整个生命周期从创建到销毁。Spring 容器使用依赖注入（DI）来管理组成一个应用程序的组件。这些对象被称为 Spring Beans，我们将在下一章中进行讨论。 
IOC 容器具有依赖注入功能的容器，它可以创建对象，IOC 容器负责实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。通常new一个实例，控制权由程序员控制，而"控制反转"是指new实例工作不由程序员来做而是交给Spring容器来做。在Spring中BeanFactory是IOC容器的实际代表者。
Spring BeanFactory 容器
Spring ApplicationContext 容器


##############################################################################################################
						并发编程
当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。

在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。

并行工作者模型
传入的作业会被分配到不同的工作者上
优点:它很容易理解。你只需添加更多的工作者来提高系统的并行度。
缺点:共享状态可能会很复杂。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免竟态，死锁以及很多其他共享状态的并发性问题。
许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。(非阻塞并发算法,可持久化的数据结构{比如Java中的String类，以及CopyOnWriteArrayList类})

流水线模式



# 进程与线程

**进程：**一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程。

**线程：**进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。

**与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。**

## 进程与线程的区别总结

线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。

**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**资源开销：**每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行
