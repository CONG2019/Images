# 可重入

- 所谓可重入是指一个可以被多个任务调用的过程，任务在调用时不必担心数据是否会出错。**一个可重入的函数简单来说就是可以被中断的函数，也就是说，可以在这个函数执行的任何时刻中断它，转入OS调度下去执行另外一段代码，而返回控制时不会出现什么错误；而不可重入的函数由于使用了一些系统资源，比如全局变量区，中断向量表等，所以它如果被中断的话，可能会出现问题，这类函数是不能运行在多任务环境下的。****也可以这样理解，重入即表示重复进入**，首先它意味着这个函数可以被中断，其次意味着它除了使用自己栈上的变量以外不依赖于任何环境（包括  static），这样的函数就是purecode（纯代码）可重入，可以允许有该函数的多个副本在运行，由于它们使用的是分离的栈，所以不会互相干扰。如果确实需要访问全局变量（包括 static），一定要注意实施互斥手段。可重入函数在并行运行环境中非常重要，但是一般要为访问全局变量付出一些性能代价。

# 内存四区

## 1.代码区

　　程序被操作系统加载到内存的时候，所有的可执行代码（程序代码指令、常量字符串等）都加载到代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。

　　注意："int a = 0;"语句可拆分成"int a;"和"a = 0"，定义变量a的"int a;"语句并不是代码，它在程序编译时就执行了，并没有放到代码区，放到代码区的只有"a = 0"这句。

## 2.静态区

　　静态区存放程序中所有的全局变量和静态变量。

## 3.栈区

　　栈（stack）是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。

- 每个线程都有自己专属的栈；
- 栈的最大尺寸固定，超出则引起栈溢出；
- 变量离开作用域后栈上的内存会自动释放。

## 4.堆区

　　堆（heap）和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决上面实验三造成的内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。对于一个32位操作系统，最大管理管理4G内存，其中1G是给操作系统自己用的，剩下的3G都是给用户程序，一个用户程序理论上可以使用3G的内存空间。堆上的内存必须手动释放（C/C++），除非语言执行环境支持GC（如C#在.NET上运行就有垃圾回收机制）。

# IIC

***IIC（Inter-Integrated Circuit）内部集成电路；多主机总线，非全双工***

还是假设A给B发数据（这里A.SCL接B.SCL, A.SDA接B.SDA）。起初SDA和SCL上的电平都为高电平。然后A先把SDA拉低，等SDA变为低电平后再把SCL拉低(以上两个动作构成了iic的起始位)，此时SDA就可以发送数据了，与此同时，SCL发送一定周期的脉冲（周期和PCLK有关，一般会在IIC的控制寄存器中设置）。SDA发送数据和SCL发送脉冲的要符合的关系是：SDA必须在SCL是高电平是保持有效，在SCL是低电平时发送下一位（SCL会在上升沿对SDA进行采样）。规定一次必须传8位数据，8位数据传输结束后A释放SDA，但SCL再发一个脉冲（这是第九个脉冲），这会触发B通过将SDA置为低电平表示确认（该低电平称为ACK）。最后SCL先变为高电平，SDA再变为高电平（以上两个动作称为结束标志）如果B没有将SDA置为0，则A停止发送下一帧数据。IIC总线（即SDA和SCL）上的每个设备都有唯一地址，数据包传输时先发送地址位，接着才是数据。一个地址字节由7个地址位（可以挂128个设备）和1个指示位组成（7位寻址模式）。指示位是0表示写，1表示读。还有10位寻址模式，使用两个字节来保存地址，第一个字节的最低两位和第二个字节的8位合起来构成10位地址。

- IIC数据从最高位开始传输。
- 用7bit表示从地址，那么可以挂载的从设备数是2的7次方128个。处理器想写的话：先发送起始位，再发一个8bit数据：前7bit表示从地址，第8bit表示读或者写。0write是处理器往IIC从设备发，1read是IIC从设备往处理器发。第9个时钟周期回复响应信号。

# SPI

***SPI(Serial Peripheral Interface)，串行外设接口。 由Motorola提出的全双工三线同步串行外围接口，采用主从模式（Master Slave）架构***

**Features**
  高速、全双工、同步通信、四线接口
**Pin**
  SCK：时钟信号 -> 主机产生，速率受限低速设备
  SS(CS/NSS)：片选 -> 低电平有效，同一时刻只允许一个设备连接
  MISO(SDI)：主设备输入/从设备输出
  MOSI(SDO)：主设备输出/从设备输入

# 形参与实参

***形式参数：形参是函数被调用时用于接收实参值的变量。***

实参(argument)： 全称为"实际参数"是在调用时传递给函数的参数. 实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。    

形参(parameter)：全称为"形式参数" 由于它不是实际存在变量，所以又称虚拟变量。是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数.在调用函数时，实参将赋值给形参。因而，必须注意实参的个数，类型应与形参一一对应，并且实参必须要有确定的值。

# Linux驱动

**三种驱动设备分类**

    字符设备(char)
    实际上就是字节设备，对设备操作的读写操作是以字节为最小单位，如控制LED灯的亮灭，串口的读写，
    
    块设备(block)
    实际是就是存储设备，其驱动操作的最小单位是块，对整个块进行操作，如HDD，Flash 都是以一个固定的Block大小进行读写，如512B等等。修改时需要读出整块到内存，对需要的地方进行修改后，再覆写整块
    
    网络设备(network)
    是一套通用的接口,实际上已经包含在内核，无需开发
# UCOSⅡ

## 锁

- OSSchedLock();
- OSSchedUnlock();

## 延时

- OSTimeDly(1000);

## 创建任务

OSTaskCreate(sign_task,(void *)0,(OS_STK*)&SIGN_TASK_STK[SIGN_STK_SIZE-1],SIGN_TASK_PRIO);

# 宏旺微电子

放开眼光看世界，打开格局做事业”。创建中华民族自主memory芯片。

- 嵌入式产品线，SSD产品线，内存条（DDR）
- 嵌入式存储、移动存储、SSD、内存条四大产品线，

宏旺半导体股份有限公司成立于2004年，是一家专注于存储芯片（国家战略产业）Design、研发、封装、测试、销售服务于一体的高科技企业。公司运营资本约为2亿美金总额。

# gcc

gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：

- 1、预处理,生成 .i 的文件[预处理器cpp] 
- 2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs] 
- 3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as] 
- 4、连接目标代码, 生成可执行程序 [链接器ld] 

**x language filename** 

设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。也就是根据约定 C 语言的后缀名称是 .c 的，而 C++ 的后缀名是 .C  或者 .cpp, 如果你很个性，决定你的 C 代码文件的后缀名是 .pig 哈哈，那你就要用这个参数,  这个参数对他后面的文件名都起作用，除非到了下一个参数的使用。 可以使用的参数吗有下面的这些：'c', 'objective-c',  'c-header', 'c++', 'cpp-output', 'assembler', 与 'assembler-with-cpp'。

看到英文，应该可以理解的。 

例子用法:

```
gcc -x c hello.pig 
```

**-x none filename** 

关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。

例子用法: 

```
gcc -x c hello.pig -x none hello2.c 
```

**-c** 

只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 

例子用法: 

```
gcc -c hello.c 
```

他将生成 .o 的 obj 文件 

**-S** 

只激活预处理和编译，就是指把文件编译成为汇编代码。 

例子用法: 

```
gcc -S hello.c 
```

他将生成 .s 的汇编代码，你可以用文本编辑器察看。 

**-E** 

只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面。 

例子用法: 

```
gcc -E hello.c > pianoapan.txt 
gcc -E hello.c | more 
```

慢慢看吧, 一个 hello word 也要与处理成800行的代码。 

**-o** 

制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out, 很难听, 如果你和我有同感，改掉它, 哈哈。

例子用法: 

```
gcc -o hello.exe hello.c (哦,windows用习惯了) 
　　gcc -o hello.asm -S hello.c
```

| ansi         | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |
| ------------ | ------------------------------------------------------------ |
| -c           | 只编译并生成目标文件。                                       |
| -DMACRO      | 以字符串"1"定义 MACRO 宏。                                   |
| -DMACRO=DEFN | 以字符串"DEFN"定义 MACRO 宏。                                |
| -E           | 只运行 C 预编译器。                                          |
| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |
| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |
| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |
| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |
| -m486        | 针对 486 进行代码优化。                                      |
| -o FILE      | 生成指定的输出文件。用在生成可执行文件时。                   |
| -O0          | 不进行优化处理。                                             |
| -O 或 -O1    | 优化生成代码。                                               |
| -O2          | 进一步优化。                                                 |
| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |
| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |
| -static      | 禁止使用共享连接。                                           |
| -UMACRO      | 取消对 MACRO 宏的定义。                                      |
| -w           | 不生成任何警告信息。                                         |
| -Wall        | 生成所有警告信息。                                           |